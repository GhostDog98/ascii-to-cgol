#include <signal.h>
#include <signal.h>
#include <thread>
#include <mutex>
#include <atomic>
#include <bitset>
#include <chrono>
#include <fstream>
#include <iostream>
#include <random>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>
#include <cstring>
#include <climits>
#include <functional>
#include "master.hpp"
#include <sys/wait.h>
#include <unistd.h>
#include "preprocessing.hpp"
using namespace std;

atomic<bool> running(true);
atomic<size_t> totalPatterns(0); // global state for total patterns output
mutex coutMutex;

string runLengthEncode(const string& str) {
    int n = str.size();
    string encoded;

    for (int i = 0; i < n; ++i) {
        int count = 1;
        while (i + 1 < n && str[i] == str[i + 1]) {
            ++count;
            ++i;
        }
        encoded += to_string(count) + str[i];
    }
    return encoded;
}


string translateFontFile(const string& chars, const vector<string>& masterDictionary) {
    vector<string> combinedRows;

    for (char c : chars) {
        if (c >= 32 && c <= 126) {
            const string& charData = masterDictionary[c - 32];
            istringstream stream(charData);
            string line;
            size_t rowIndex = 0;

            while (getline(stream, line)) {
                if (rowIndex >= combinedRows.size()) {
                    combinedRows.emplace_back();
                }
                combinedRows[rowIndex] += line;
                ++rowIndex;
            }
        } else {
            size_t charHeight = 16;
            size_t charWidth = 8;
            for (size_t rowIndex = 0; rowIndex < charHeight; ++rowIndex) {
                if (rowIndex >= combinedRows.size()) {
                    combinedRows.emplace_back();
                }
                combinedRows[rowIndex] += string(charWidth, '0');
            }
        }
    }

    ostringstream result;
    for (const auto& row : combinedRows) {
        result << row << '\n';
    }
    return result.str();
}

string conway_encode(const string& chars, const vector<string>& masterDictionary) {  // 99% of time
    string result = translateFontFile(chars, masterDictionary);                      // 52% of time

    // Pre-allocate exactly 16 rows
    vector<string> lines(16);
    int x_max = 0;
    int y_max = 0;

    istringstream stream(result);
    string line;

    // Process each line from the translated font data
    while (getline(stream, line) && y_max < 16) {  // Ensure `lines` never exceeds 16 rows
        if (!line.empty() && line.find('1') != string::npos) {
            x_max = max(x_max, static_cast<int>(line.size()));

            // Replace '0' → 'b' and '1' → 'o'
            for (char& ch : line) {
                ch = (ch == '0') ? 'b' : 'o';
            }

            // Store the encoded line in pre-allocated vector
            lines[y_max++] = runLengthEncode(line);  // 22% of time
        }
    }

    // Create the final RLE-formatted output
    ostringstream final_stream;
    // final_stream << "#C Generated by ASCII-to-Conway program\n";
    // final_stream << "#r 23/3\n";
    // final_stream << format("x = {}, y = {}\n", x_max, y_max);

    // Output encoded lines, separating rows with '$'
    for (int i = 0; i < y_max; ++i) {
        final_stream << lines[i];
        if (i < y_max - 1) {
            final_stream << "$";
        }
    }
    final_stream << "!";

    return final_stream.str();
}

const string CHARACTERS =
    " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";

void generate_combination(size_t number, size_t length, const string& characters, string& out) {
    size_t base = characters.size();
    for (size_t i = 0; i < length; ++i) {
        out[length - i - 1] = characters[number % base];
        number /= base;
    }
}

bool next_combination(string& current, const string& characters) {
    for (size_t i = current.size(); i-- > 0;) {
        if (current[i] != characters.back()) {
            current[i] = characters[characters.find(current[i]) + 1];
            return true;
        }
        current[i] = characters.front();
    }
    return false; // Reached the final combination
}

void handle_signal(int signal) {
    if (signal == SIGINT) {
        running = false;
    }
}

mutex statsMutex;
size_t totalChars = 0;
size_t iterations = 0;

void workerFunction(size_t start, size_t end, const vector<string>& masterDictionary, size_t testLength, const string& characters, const vector<const char*>& apgluxeArgs) {
    string currentPattern(testLength, characters.front());

    // Create a pipe for communication
    int pipefd[2];
    if (pipe(pipefd) == -1) {
        perror("pipe");
        return;
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        return;
    }

    if (pid == 0) {  // Child process
        // Close the write end of the pipe
        close(pipefd[1]);

        // Redirect the read end of the pipe to stdin
        dup2(pipefd[0], STDIN_FILENO);

        // Close the read end of the pipe after duplication
        close(pipefd[0]);

        // Execute apgluxe with collected args
        execvp("./apgluxe", const_cast<char* const*>(apgluxeArgs.data()));
        perror("execlp"); // If exec failed
        exit(EXIT_FAILURE);
    } else {  // Parent process
        // Close the read end of the pipe
        close(pipefd[0]);

        // Write to the pipe
        for (size_t i = start; i < end && running; ++i) {
            generate_combination(i, testLength, characters, currentPattern);
            string encoded = conway_encode(currentPattern, masterDictionary);

            {
                string output = "x = 0, y = 0, rule=B3/S23\n" + encoded + "\n";
                if (write(pipefd[1], output.c_str(), output.size()) == -1) {
                    perror("write");
                }
            }

            {
                lock_guard<mutex> lock(statsMutex);
                totalChars += currentPattern.size();
                ++iterations;
            }
        }

        // Send two newlines before closing the write end of the pipe
        string endTransmission = "\n\n";
        if (write(pipefd[1], endTransmission.c_str(), endTransmission.size()) == -1) {
            perror("write");
        }

        // Close the write end of the pipe to signal EOF
        close(pipefd[1]);
        
        // Wait for the child process to exit
        int status;
        waitpid(pid, &status, 0);

        // Check the status of the child process
        if (WIFEXITED(status)) {
            int exitStatus = WEXITSTATUS(status);
            if (exitStatus != 0) {
                cerr << "Child exited with status " << exitStatus << endl;
            }
        } else if (WIFSIGNALED(status)) {
            cerr << "Child process was terminated by signal " << WTERMSIG(status) << endl;
        }
    }
}



// ./recompile --symmetry letters_stdin
// then `./conway -l <n> -- -t 1 -n 999999
int main(int argc, char* argv[]) {
    size_t testLength = 2;  // Default value for test length
    int opt;

    if(argc <= 1){
        cerr << "Usage: " << argv[0] << " -l <testlength> -- <apgluxe arguments>" << endl;
        cerr << "Example: \n" << "./conway -l 5 -- -t 1 -n 99" << endl;
        return EXIT_FAILURE;
    }

    // Option parsing
    while ((opt = getopt(argc, argv, "l:")) != -1) {
        switch (opt) {
            case 'l':
                testLength = stoi(optarg);
                break;
            default:
                cerr << "Usage: " << argv[0] << " [-l testLength]" << endl;
                return EXIT_FAILURE;
        }
    }

    vector<const char*> apgluxeArgs = {"apgluxe"};

    // Add additional arguments after the `--`
    for (int i = optind; i < argc; ++i){
        apgluxeArgs.push_back(argv[i]);
    }
    apgluxeArgs.push_back(nullptr);



    size_t threadCount = thread::hardware_concurrency();
    size_t totalCombinations = std::pow(CHARACTERS.size(), testLength);

    //vector<string> masterDictionary = form_translator("your_font_file.txt");
    vector<thread> workers;
    size_t chunkSize = totalCombinations / threadCount;

    for (size_t i = 0; i < threadCount; ++i) {
        size_t start = i * chunkSize;
        size_t end = (i == threadCount - 1) ? totalCombinations : (i + 1) * chunkSize;
        workers.emplace_back(workerFunction, start, end, cref(masterDictionary), testLength, cref(CHARACTERS), cref(apgluxeArgs));
    }

    for (auto& worker : workers) {
        if (worker.joinable()) {
            worker.join();
        }
    }

    return 0;
}