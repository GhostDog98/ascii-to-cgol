import sys, unicodedata
import numpy as np

def read_between_markers(file_path, start_marker="STARTCHAR", end_marker="ENDCHAR", onlyascii = False):
    contents = {}
    current_key = None
    current_section = []
    line_count = 0
    with open(file_path, 'r', encoding='UTF-8') as file:
        for line in file:
            line_count += 1
            if onlyascii == True and line_count > 2975:
                break

            line = line.strip()  # Remove leading/trailing whitespace
            
            if line.startswith(start_marker):
                if current_key is not None:  # Store previous section if it exists
                    contents[current_key] = current_section
                
                current_key = chr(int(line[len(start_marker):].strip()[2:], 16))  # Extract key
                current_section = []  # Start a new section
            elif line == end_marker and current_key is not None:
                contents[current_key] = current_section
                current_key = None  # Reset for next section
            elif current_key is not None:  # Collect lines between markers
                current_section.append(line)

    # Handle the last section if the file ends without an ENDCHAR
    if current_key is not None:
        contents[current_key] = current_section

    return contents

def form_translator(file_to_read):
    sections = read_between_markers(file_to_read)
    translated_form = {}
    for key, value in sections.items():
        # Get the bounding width from the third element
        bounding_width = int(value[3].split()[1])

        translated_form[key] = [
            list(bin(int(code, 16))[2:].zfill(bounding_width))
            for code in value[5:]
        ]
    return (translated_form)

def translate_font_file(file_path, chars):
    master_dictionary = form_translator(file_path)
    char_arrays = [master_dictionary.get(char, []) for char in chars]

    # Combine arrays by merging rows from each character
    combined_array = []
    max_rows = max(len(char) for char in char_arrays)  # Find the longest character array

    for row_index in range(max_rows):
        combined_row = []
        for char in char_arrays:
            if row_index < len(char):
                combined_row.extend(char[row_index])  # Append row if it exists for the character
            else:
                # Fill missing rows with blank spaces if character has fewer rows
                combined_row.extend(['0'] * len(char[0]))
        combined_array.append(combined_row)

    transfer_array = "\n".join(["".join(row) for row in combined_array])
    return (transfer_array)

def rle_encode(data):
    if not data:
        return ''

    encoding = []
    prev_char = data[0]
    count = 1

    for char in data[1:]:
        if char != prev_char:
            encoding.append(f"{count}{prev_char}")
            count = 1
            prev_char = char
        else:
            count += 1
    encoding.append(f"{count}{prev_char}")  # Finish off the encoding
    return ''.join(encoding)

def conway_rle_translate(result):
    result_line_array = result.split()
    x_max = len(result_line_array[0])  # assume a uniform length
    y_max = len(result_line_array)
    
    first_lines = (
        "#C Generated by Lilly's ascii-to-conway program\n"
        "#r 23/3\n"
        f"x = {y_max}, y = {x_max}"
    )
    
    rest_of_lines = []
    for line in result_line_array:
        if "1" in line:
            line = line.rstrip('0')  # remove end 0's
        line = line.replace('0', 'b').replace('1', 'o')  # replace dead and live cells
        rest_of_lines.append(rle_encode(line))

    print(first_lines)
    for line in rest_of_lines:
        if line:
            print(line + "$", end='')
    print("\n")

if __name__ == "__main__":
    # Example usage
    file_path = 'font.bdf'  # Replace with your actual file path

    #chars_to_translate = 'testing'  # The characters you want to combine
    result = translate_font_file(file_path, "8\x00 あ ぃ い ぅ う ぇ え ぉ お ")
    conway_rle_translate(result)